/******************************************************************************
* Copyright (C) 2025 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/

include "routingtype.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
def routing_createtilearrayOp : routingop<"routingcreatetilearray", [DeclareOpInterfaceMethods<InferTypeOpInterface>]> {
	let summary = "createtilearray";
	let cppNamespace = "routing";
	let description = "create a tile array";
	let arguments = ( ins
		I32:$rownum,
		I32:$colnum
	);
	let results = (outs
		tilearray:$output
	);
	let assemblyFormat = "$rownum $colnum `:` type($rownum) type($colnum) attr-dict `->` type($output)";
}

def routing_createdataio : routingop<"routingcreatedataio", [DeclareOpInterfaceMethods<InferTypeOpInterface>]> {
	let summary = "createdataio";
	let cppNamespace = "routing";
	let description = "create data io";

	let arguments = (ins
		StrAttr:$iotype,
		StrAttr:$direction
	);
	let results = (outs
		dataio:$output
	);
	let assemblyFormat = " $iotype `,` $direction attr-dict `->` type($output)";
}

def routing_createhwiowithtarget : routingop<"routingcreatehwiowithtarget"> {
	let summary = "createhwiowithtarget";
	let cppNamespace = "routing";
	let description = "create hw io with target";
	let arguments = (ins
		I32:$targettilelist,
		StrAttr:$direction,
		StrAttr:$iotype
	);
	let results = (outs
		I32:$output
	);
	let assemblyFormat = " `targettilelist` `=` $targettilelist `:` type($targettilelist) attr-dict `->` type($output)";
}

def routing_creatbroadcast : routingop<"routingcreatebroadcast"> {
	let summary = "createbroadcast";
	let cppNamespace = "routing";
	let description = "create a broadcast";

	let arguments = (ins
		dataio:$io,
		tilearray:$tilearray);

	let results = (outs
		I32:$output);
	let assemblyFormat = "$io `,` $tilearray `:` type($io) `,` type($tilearray)  attr-dict`->` type($output)";
}

def routing_movedatabyio : routingop<"routingmovedatabyio "> {
	let summary = "movedatabyio";
	let cppNamespace = "routing";
	let description = "move data through io to aie or from";

	let arguments = (ins
		I32:$pktmerge_or_slicetestor,
		I32:$hwiowithtarget);

	let results = (outs
		I32:$output);
	let assemblyFormat = " `pktmerge_or_slicetestor` `=` $pktmerge_or_slicetestor `,` `hwiowithtarget` `=` $hwiowithtarget `:` type($pktmerge_or_slicetestor) `,` type($hwiowithtarget)  attr-dict`->` type($output)";
}

def routing_createhwmesh :routingop<"routingcreatehwmesh"> {
	let summary = "createhwmesh";
	let cppNamespace = "routing";
	let description = "create an hw mesh";

	let arguments = (ins
		I64Attr:$row,
		I64Attr:$col
		);

	let results = (outs
		I32:$output);

	let assemblyFormat = " attr-dict `->` type($output)";	

}

def routing_createdummytensor :routingop<"routingcreatedummytensor"> {
	let summary = "createdummytensor";
	let cppNamespace = "routing";
	let description = "create an dummpy tensor";

	let arguments = (ins
		I64ArrayAttr:$shape,
		I64Attr:$dim
		);

	let results = (outs
		I32:$output);

	let assemblyFormat = "attr-dict `->` type($output)";	

}

def routing_partitionmesh :routingop<"routingpartitionmesh"> {
	let summary = "partitionmesh";
	let cppNamespace = "routing";
	let description = "partitionmesh";

	let arguments = (ins
		I32:$mesh,
		I32Attr:$splitnum,
		StrAttr:$splitaxis
		);

	let results = (outs
		I32:$output);

	let assemblyFormat = [{`mesh` `=` $mesh `:` type($mesh) attr-dict `->` type($output)}];	

}

def routing_partitiontensor :routingop<"routingpartitiontensor"> {
	let summary = "partitiontensor";
	let cppNamespace = "routing";
	let description = "partitionmtensor";

	let arguments = (ins
		I32:$tensor,
		I32Attr:$splitnum,
		I32Attr:$splitdim,
		StrAttr:$hw_axis_owner,
		StrAttr:$replicate_on,
		StrAttr:$single_tile_owner
	);

	let results = (outs
		I32:$output);
	
	let assemblyFormat = [{
		`tensor` `=` $tensor `:` type($tensor) attr-dict `->` type($output)
	}];	

}

def routing_extract_data :routingop<"routingextract_data"> {
	let summary = "extract_data";
	let cppNamespace = "routing";
	let description = "extract_data";

	let arguments = (ins
		I32:$tensor,
		I32:$idx
	);

	let results = (outs
		I32:$output);

	let assemblyFormat = "$tensor `,`  $idx `:` type($tensor) `,` type($idx) attr-dict `->` type($output)";	

}

def routing_extract_tiles :routingop<"routingextract_tiles"> {
	let summary = "extract_tiles";
	let cppNamespace = "routing";
	let description = "extract_tiles";

	let arguments = (ins
		I32:$partitions,
		I32:$idx
	);

	let results = (outs
		I32:$output);

	let assemblyFormat = "$partitions `,`  $idx `:` type($partitions) `,` type($idx) attr-dict `->` type($output)";	

}

def Routing_YieldOp : routingop<"yield", [Terminator]> {
  let summary = "Terminator for regions in routing ops";
  let description = [{
    The `routing.yield` operation is a terminator that yields a value from
    a region within a `routing` operation.
  }];

  //let arguments = (ins AnyType:$value);
  let arguments = (ins);
  let results = (outs); // No results
}

def Routing_RoutingCreate : routingop<"RoutingCreate", []> {
  let summary = "A structured operation for routing logic";
  let description = [{
    Represents a dispatch of a value through a routing pipeline,
    configured by a static device_row attribute. The operation contains
    a region that defines the routing logic.
  }];

  let arguments = (ins 
  				   I32:$Hwmesh,
				   I32:$Datatensor,
				   I32Attr:$Meshsplitnum,
				   StrAttr:$Meshsplitaxis,
				   I32Attr:$Datasplitnum,
				   I32Attr:$Datasplitdim,
				   StrAttr:$Dataslicehwaxisowner,
				   StrAttr:$Dataslicehwreplicateon,
				   StrAttr:$Datasingletileowner,
				   StrAttr:$Iotargetdirection
				   );
  let results = (outs I32:$output);

  let regions = (region SizedRegion<1>:$body);
 

  let builders = [
    OpBuilder<(ins "Value":$Hwmesh, 
				   "Value":$Datatensor, 
				   "Attribute":$Meshsplitnum,
				   "Attribute":$Meshsplitaxis,
				   "Attribute":$Datasplitnum,
				   "Attribute":$Datasplitdim,
				   "Attribute":$Dataslicehwaxisowner,
				   "Attribute":$Dataslicehwreplicateon,
				   "Attribute":$Datasingletileowner,
				   "Attribute":$Iotargetdirection,
                   "function_ref<void(OpBuilder &, Location, Value,Value)>":$bodyBuilder),
    [{
      // no region creatation
	  // 2. Add operands to the state object.
      $_state.addTypes($_builder.getI32Type());//for output , the result
      $_state.addOperands(Hwmesh);
	  $_state.addOperands(Datatensor);
	  
      // 3. Add attributes to the state object.
      // Note that we must provide the attribute's name as a string.
      $_state.addAttribute("Meshsplitnum", Meshsplitnum);
	  $_state.addAttribute("Meshsplitaxis", Meshsplitaxis);
	  $_state.addAttribute("Datasplitnum", Datasplitnum);
	  $_state.addAttribute("Datasplitdim", Datasplitdim);
	  $_state.addAttribute("Dataslicehwaxisowner", Dataslicehwaxisowner);
	  $_state.addAttribute("Dataslicehwreplicateon", Dataslicehwreplicateon);
	  $_state.addAttribute("Datasingletileowner", Datasingletileowner);
	  $_state.addAttribute("Iotargetdirection", Iotargetdirection);

      // 2. 创建 Region 和 Block
      auto *bodyRegion = $_state.addRegion();
      Block *bodyBlock = new Block();
      bodyRegion->push_back(bodyBlock);
      bodyBlock->addArgument(Hwmesh.getType(), Hwmesh.getLoc());
	  bodyBlock->addArgument(Datatensor.getType(), Datatensor.getLoc());

      // 3. 调用用户提供的 lambda 来填充 Block
      OpBuilder::InsertionGuard guard($_builder);
      $_builder.setInsertionPointToStart(bodyBlock);
      bodyBuilder($_builder, 
	  			  Hwmesh.getLoc(),
				  bodyBlock->getArgument(0),
				  bodyBlock->getArgument(1)
				  );
    }]>
  ];

  // --- 添加一个验证器 ---
  /*
  let verifier = [{
    // verify region and argument
    if (getRegion().front().getArgument(0).getType() != getInput().getType())
      return emitOpError("region argument type must match input type");

    // verify yeild
    auto yieldOp = getRegion().front().getTerminator();
    if (yieldOp->getOperand(0).getType() != getResult().getType())
      return emitOpError("yield type must match result type");
  }];
*/
  // 
  //let assemblyFormat = [{ `(` $input `)` attr-dict `->` type($output) region $body
  //}];
  let hasCustomAssemblyFormat = 1;
}

